#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2012             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

# Author: Jeremy Leggat <jleggat@asu.edu>

### Collect and dump XSAN information.

import os
import re
import subprocess
import sys

if os.path.isfile('/usr/sbin/cvadmin'): pass
else: sys.exit()

def get_fsm(lines):
  dict = {}
  regex = re.compile(r'(\*|\s)(\w+)\[(\d)\]  port (\d+), pid (\d+)\n +State: (\w+) (\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2})\n +Launches (\d+), core dumps (\d+), flags \<(.*)\>')
  for line in lines.split("\n\n"):
    m = regex.search(line)
    if m:
      attribs = []
      for x in m.groups(): attribs.append(x)
      if (attribs.pop(0)).isspace(): attribs.append("standby")
      else: attribs.append("controler")
      dict[attribs.pop(0)] = attribs
  return dict

def parse_show(key):
  cmd = "/usr/sbin/cvadmin -F %s -e show long" % (key)
  procs = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
  show_list = procs.communicate()
  for group in show_list[0].split("\n\n"):
    if group.startswith( "Stripe Group" ):
      m1 = re.search("Stripe Group (?P<number>\d)\s\[(?P<name>.+)\]  Status:(?P<status>.*)\n\s+Total Blocks:(?P<total>\d+) .* Reserved:(?P<reserved>\d+) .* Free:(?P<free>\d+) .* \((?P<percent>.*)%\)", group)
      attribs = ['stripe']
      attribs.append(key)
      for x in m1.groups(): attribs.append(x)
      print "\t".join((attribs))

def parse_stat(key):
  attribs = ['stats']
  attribs.append(key)
  cmd = "/usr/sbin/cvadmin -F %s -e stat" % (key)
  procs = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
  stat_list = procs.communicate()
  for line in stat_list[0].split("\n"):
    match = re.search("\w.*\w\s+\:\s+(\w.*[\w\)]?)",line)
    if match:
      v = re.sub ( "\(|\)|%", "", match.group(1) )
      attribs.append(v)
  print "\t".join(attribs)

def parse_paths():
  cmd = "/usr/sbin/cvadmin -e paths"
  procs = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
  paths_list = procs.communicate()
  for groups in paths_list[0].split("\n\n"):
    if groups.startswith( "Controller" ):
      m1 = re.search("Controller: <(\w+)>",groups)
      con = m1.group(1)
      for line in groups.split("\n"):
        match = re.search("(?x)(\w+)\s+on.device:.(\wdisk\d+)\s+hba:.(\d+)\sctl:.(\d+)\slun:.(\d+)\sstate:.(\w+)",line)
        if match:
          attribs = ['paths']
#          attribs.append(key)
          for x in match.groups(): attribs.append(x)
          attribs.append(con)
          print "\t".join((attribs))

def parse_disks():
  cmd = "/usr/sbin/cvadmin -e disks"
  procs = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
  disks_list = procs.communicate()
  for line in disks_list[0].split("\n"):
    match = re.search("^(\w+)\s+on device:(\wdisk\d+)\ssectors: (\d+)\s+sector size: (\d+)",line)
    if match:
      attribs = ['disks']
#      attribs.append(key)
      for x in match.groups(): attribs.append(x)
      print "\t".join((attribs))

fsm_cmd = "/usr/sbin/cvadmin -e fsmlist"
process = subprocess.Popen(fsm_cmd, shell=True, stdout=subprocess.PIPE)
fsmlist = process.communicate()

fsm_dict = get_fsm(fsmlist[0])

if fsm_dict:
  print '<<<xsan>>>'

for key in fsm_dict:
  print 'fsm\t' + key + "\t" + "\t".join(fsm_dict[key])
  parse_stat(key)
  parse_show(key)

parse_paths()
parse_disks()
